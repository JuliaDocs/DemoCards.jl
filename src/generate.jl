"""
    makedemos(source::String, templates::Dict;
              root = "<current-directory>",
              destination = "democards",
              src = "src",
              build = "build",
              branch = "gh-pages",
              edit_branch = "master",
              credit = true) -> page_path, postprocess_cb

Make a demo page for `source` and return the path to the generated index file.

Processing pipeline:

1. analyze the folder structure `source` and loading all available configs.
2. copy assets
3. preprocess demo files and save it
4. save/copy cover images
5. generate postprocess callback function, which includes url-redirection.

!!! note
    By default, the source demo files are read, processed and save to `docs/src/democards`,
    so if you put all source demo files in `docs/src`, there will be a duplication of files and assets.
    Thus, it's recommended to not put your original page folder in `docs/src`, and it's prefered
    to git ignore `docs/src/democards`


# Outputs

* `page_path`: path to demo page's index. You can directly pass it to `makedocs`.
* `postprocess_cb`: callback function for postprocess. You can call `postprocess_cb()` _after_ `makedocs`.

# Keywords

* `root::String`: should be equal to `Documenter`'s setting. By default it's `"docs"`.
* `destination::String`: The folder name in generated documentation. By default it's `"democards"`.
* `src::String`: should be equal to `Documenter`'s setting. By default it's `"src"`.
* `build::String`: should be equal to `Documenter`'s setting. By default it's `"build"`.
* `edit_branch::String`: should be equal to `Documenter`'s setting. By default it's `"master"`.
* `branch::String`: should be equal to `Documenter`'s setting. By default it's `"gh-pages"`.
* `credit::String`: `true` to show a "This page is generated by ..." info. By default it's `true`.

# Examples

The following is a minimal example for you to start

```julia
# 1. generate templates and stylesheets with predefined themes
templates, theme = cardtheme()

# 2. preprocess and generate demo files to docs/src/democards
examples, postprocess_cb = makedemos("examples", templates)

# 3. pass stylesheet to HTML assets
format = Documenter.HTML(edit_branch = "master",
                         assets = [theme])

# 4. do the standard Documenter pipeline
makedocs(format = format,
         pages = [
            "Home" => "index.md",
            "Examples" => examples,
         ])

# 5. postprocessing
postprocess_cb()
```
"""
function makedemos(source::String, templates::Dict;
                   root::String = Base.source_dir(),
                   destination::String = "democards",
                   src::String = "src",
                   build::String = "build",
                   branch::String = "gh-pages",
                   edit_branch::String = "master",
                   credit = true)

    root = abspath(root)
    page_root = abspath(root, source)

    if page_root == source
        # reach here when source is absolute path
        startswith(source, root) || throw(ArgumentError("invalid demo page source $page_root"))
    end

    page = DemoPage(page_root)

    relative_root = joinpath(destination, basename(page))

    # Where files are generated by DemoCards for Documenter.makedocs
    # e.g "$PROJECT_ROOT/docs/src/democards/quickstart"
    absolute_root = joinpath(root, src, relative_root)
    isdir(absolute_root) && rm(absolute_root; force=true, recursive=true)

    # we can directly pass it to Documenter.makedocs
    out_path = joinpath(relative_root, "index.md")

    @info "SetupDemoCardsDirectory: setting up $(source) directory."
    rm(absolute_root; force=true, recursive=true)
    mkpath(absolute_root)
    # hard coded "covers" should be consistant to card template
    mkpath(joinpath(absolute_root, "covers"))

    # make a copy before pipeline because `save_democards` modifies card path
    source_files = [x.path for x in flatten(page)]

    # pipeline
    copy_assets(absolute_root, page)
    # WARNING: julia cards are reconfigured here
    save_democards(absolute_root, page;
                   project_root = root,
                   src = src,
                   credit = credit,
                   nbviewer_root_url = get_nbviewer_root_url(branch))
    save_cover(joinpath(absolute_root, "covers"), page)
    generate(joinpath(absolute_root, "index.md"), page, templates)

    # pipeline: generate postprocess callback function
    postprocess_cb = ()->begin
        @info "Redirect URL: redirect docs-edit-link for demos in $(source) directory."
        push!(source_files, joinpath(page_root, "index.md"))
        foreach(source_files) do source_file
            redirect_link(source_file, source, root, destination, src, build, edit_branch)
        end
    end

    return out_path, postprocess_cb
end

function generate(file::String, page::DemoPage, args...)
    check_ext(file, :markdown)
    open(file, "w") do f
        generate(f, page::DemoPage, args...)
    end
end
generate(io::IO, page::DemoPage, args...) = write(io, generate(page, args...))


function generate(page::DemoPage, templates)
    items = Dict("democards" => generate(page.sections, templates))
    Mustache.render(page.template, items)
end

function generate(cards::AbstractVector{<:AbstractDemoCard}, template)
    # for those hidden cards, only generate the necessary assets and files, but don't add them into
    # the index.md page
    foreach(filter(x->x.hidden, cards)) do x
        generate(x, template)
    end

    mapreduce(*, filter(x->!x.hidden, cards); init="") do x
        generate(x, template)
    end
end

function generate(secs::AbstractVector{DemoSection}, templates; level=1)
    mapreduce(*, secs; init="") do x
        generate(x, templates;level=level)
    end
end

function generate(sec::DemoSection, templates; level=1)
    header = repeat("#", level) * " " * sec.title * "\n"
    footer = "\n"
    # either cards or subsections are empty
    # recursively generate the page contents
    if isempty(sec.cards)
        body = generate(sec.subsections, templates; level=level+1)
    else
        items = Dict(
            "cards" => generate(sec.cards, templates["card"]),
            "description" => sec.description
        )
        body = Mustache.render(templates["section"], items)
    end
    header * body * footer
end

function generate(card::AbstractDemoCard, template)
    covername = get_covername(card)

    if isnothing(covername)
        # `generate` are called after `save_cover`, we assume that this default cover file is
        # already generated
        coverpath = "covers/" * basename(get_logopath())
    else
        coverpath = is_remote_url(card.cover) ? covername : "covers/" * covername
    end
    
    description = card.description
    cut_idx = 500
    if length(card.description) >= cut_idx
        # cut descriptions into ~500 characters
        offset = findfirst(' ', description[cut_idx:end])
        offset == nothing && (offset = 0)
        offset = cut_idx + offset - 2
        description = description[1:cut_idx] * "..."
    end

    items = Dict(
        "coverpath" => coverpath,
        "id" => card.id,
        "title" => card.title,
        "description" => description,
    )
    Mustache.render(template, items)
end

### save demo card covers

save_cover(path::String, page::DemoPage) = save_cover.(path, page.sections)
function save_cover(path::String, sec::DemoSection)
    save_cover.(path, sec.subsections)
    save_cover.(path, sec.cards)
end

"""
    save_cover(path::String, card::AbstractDemoCard)

process the cover image and save it.
"""
function save_cover(path::String, card::AbstractDemoCard)
    covername = get_covername(card)
    if isnothing(covername)
        default_coverpath = get_logopath()
        cover_path = joinpath(path, basename(default_coverpath))
        !isfile(cover_path) && cp(default_coverpath, cover_path)

        # now card uses default cover file as a fallback
        card.cover = basename(default_coverpath)
        return nothing
    end

    is_remote_url(card.cover) && return nothing

    # only save cover image if it is a existing local file
    src_path = joinpath(dirname(card.path), card.cover)
    if !isfile(src_path)
        @warn "cover file doesn't exists" cover_path=src_path

        # reset it back to nothing and fallback to use default cover
        card.cover = nothing
        save_cover(path, card)
    else
        cover_path = joinpath(path, covername)
        if isfile(cover_path)
            @warn "cover file already exists, perhaps you have demos of the same filename" cover_path
        end
        !isfile(cover_path) && cp(src_path, cover_path)
    end
end

function get_covername(card::AbstractDemoCard)
    isnothing(card.cover) && return nothing
    is_remote_url(card.cover) && return card.cover

    default_covername = basename(get_logopath())
    card.cover == default_covername && return default_covername
    
    return splitext(basename(card))[1] * splitext(card.cover)[2]
end

get_logopath() = joinpath(pkgdir(DemoCards), "assets", "democards_logo.svg")

### save markdown files

"""
    save_democards(root::String, page::DemoPage; credit, nbviewer_root_url)

recursively process and save source demo file
"""
function save_democards(root::String, page::DemoPage; kwargs...)
    save_democards.(root, page.sections; kwargs...)
end
function save_democards(root::String, sec::DemoSection; kwargs...)
    save_democards.(joinpath(root, basename(sec.root)), sec.subsections;
                    kwargs...)
    save_democards.(joinpath(root, basename(sec.root)), sec.cards;
                    kwargs...)
end

### copy assets

function copy_assets(path::String, page::DemoPage)
    _copy_assets(dirname(path), page.root)
    copy_assets.(path, page.sections)
end
function copy_assets(path::String, sec::DemoSection)
    _copy_assets(path, sec.root)
    copy_assets.(joinpath(path, basename(sec.root)), sec.subsections)
end

function _copy_assets(dest_root::String, src_root::String)
    # copy assets of this section
    assets_dirs = filter(x->isdir(x)&&(basename(x) in ignored_dirnames),
                         joinpath.(src_root, readdir(src_root)))
    map(assets_dirs) do src
        dest = joinpath(dest_root, basename(src_root), basename(src))
        mkpath(dest)
        cp(src, dest; force=true)
    end
end

### postprocess

"""
    redirect_link(src_file, source, root, destination, src, build, edit_branch)

Redirect the "Edit On GitHub" link of generated demo files to its original url, without
this a 404 error is expected.
"""
function redirect_link(source_file, source, root, destination, src, build, edit_branch)
    build_file = get_build_file(source_file, source, destination, build)
    if !isfile(build_file)
        @warn "$build_file doesn't exists, skip"
        return nothing
    end
    contents = read(build_file, String)

    if !isfile(source_file)
        # reach here when user doesn't create a page template index.md
        # just remove the whole button so that user don't click and get 404
        new_contents = replace(contents, regex_edit_on_github=>"")
    else
        # otherwise, redirect the url links
        m = match(regex_edit_on_github, contents)
        isnothing(m) && return nothing
        build_url = m.captures[1]

        src_url = get_source_url(build_url, source, basename(source_file), src, destination)
        new_contents = replace(contents, build_url=>src_url)
    end
    write(build_file, new_contents)
end

function get_source_url(build_url, source, cardname, src, destination)
    # given input:
    #   - projct_root:          "$REPO/blob/$edit_branch"
    #   - build_root:           "$projct_root/$docs_root/$src/$destination"
    #   - build_dir:            "$build_root/$prefix/$page/$section/$subsection"
    #   - build_url:            "$build_dir/$cardfile"
    # example of build_url:
    #  "https://github.com/johnnychen94/DemoCards.jl/blob/master/docs/src/democards/quickstart/usage_example/julia_demos/2.cover_on_the_fly.md"
    # we need to generate:
    #   - src_root:             "$projct_root/$docs_root/$src"
    #   - src_dir:              "$src_root/$prefix/$page/$section/$subsection"
    #   - src_url:              "$src_dir/$cardfile"
    # example of src_url:
    #   "https://github.com/johnnychen94/DemoCards.jl/blob/master/docs/quickstart/usage_example/julia_demos/2.cover_on_the_fly.jl"
    source = replace(source, Base.Filesystem.path_separator => "/")

    repo, path = strip.(split(build_url, "/blob/"; limit=2), '/')
    root_to_subsection = replace(splitdir(path)[1], "$(src)/$(destination)/" => ""; count=1)
    root_to_subsection = replace(root_to_subsection, "/$(basename(source))/" => "/$(source)/"; count=1)
    src_url = join([repo, "blob", root_to_subsection, cardname], "/")

    return src_url
end

function get_build_file(source_file, source, destination, build)
    # given inputs:
    #   - source_file: "$source_root/$prefix/$page/$section/$subsection/$card.md"
    #   - source:      "$prefix/$page
    #   - destination: "democards"
    #   - build:       "build"
    # we need to generate:
    #   - build_root: "$source_root/$build/$destination"
    #   - build_dir: "$build_root/$page/$section/$subsection
    #   - build_file: "$build_dir/$card.html" or "$build_dir/$card/index.html"

    sep = Base.Filesystem.path_separator
    # add trailing / to avoid incorrect substring match
    source_root = first(split(source_file, source * sep; limit=2))
    build_root = joinpath(source_root, build, destination)
    prefix, page = splitdir(source)

    source_dir, name = splitdir(source_file)
    card, ext = splitext(name)
    _, prefix_to_subsection = split(source_dir, source_root; limit=2)
    if !isempty(prefix)
        # add trailing / to remove leading / for prefix_to_subsection
        # otherwise, joinpath of two absolute path would simply drop the first one
        _, prefix_to_subsection = split(prefix_to_subsection, prefix * sep; limit=2)
    end
    build_dir = joinpath(build_root, prefix_to_subsection)

    prettyurls = isdir(joinpath(build_dir, card))
    # Documenter.HTML behaves differently on prettyurls
    if prettyurls
        build_file = joinpath(build_dir, card, "index.html")
    else
        build_file = joinpath(build_dir, card * ".html")
    end
    return build_file
end

# modified from https://github.com/fredrikekre/Literate.jl to replace the use of @__NBVIEWER_ROOT_URL__
function get_nbviewer_root_url(branch)
    if haskey(ENV, "HAS_JOSH_K_SEAL_OF_APPROVAL") # Travis CI
        repo_slug = get(ENV, "TRAVIS_REPO_SLUG", "unknown-repository")
        deploy_folder = if get(ENV, "TRAVIS_PULL_REQUEST", nothing) == "false"
            tag = ENV["TRAVIS_TAG"]
            isempty(tag) ? "dev" : tag
        else
            "previews/PR$(get(ENV, "TRAVIS_PULL_REQUEST", "##"))"
        end
        return "https://nbviewer.jupyter.org/github/$(repo_slug)/blob/$(branch)/$(deploy_folder)"
    elseif haskey(ENV, "GITHUB_ACTIONS")
        repo_slug = get(ENV, "GITHUB_REPOSITORY", "unknown-repository")
        deploy_folder = if get(ENV, "GITHUB_EVENT_NAME", nothing) == "push"
            if (m = match(r"^refs\/tags\/(.*)$", get(ENV, "GITHUB_REF", ""))) !== nothing
                String(m.captures[1])
            else
                "dev"
            end
        elseif (m = match(r"refs\/pull\/(\d+)\/merge", get(ENV, "GITHUB_REF", ""))) !== nothing
            "previews/PR$(m.captures[1])"
        else
            "dev"
        end
        return "https://nbviewer.jupyter.org/github/$(repo_slug)/blob/$(branch)/$(deploy_folder)"
    elseif haskey(ENV, "GITLAB_CI")
        if (url = get(ENV, "CI_PROJECT_URL", nothing)) !== nothing
            cfg["repo_root_url"] = "$(url)/blob/$(devbranch)"
        end
        if (url = get(ENV, "CI_PAGES_URL", nothing)) !== nothing &&
           (m = match(r"https://(.+)", url)) !== nothing
            return "https://nbviewer.jupyter.org/urls/$(m[1])"
        end
    end
    return ""
end
